<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mine Sweeper</title>
  </head>
  <body>
    <div id="board"></div>
  </body>
  <script>
    const Keyboardkeys = {
      Space: 32,
      One: 49,
      Two: 50,
      Three: 51,
      Up: 38,
      Down: 40,
      Enter: 13
    }

    const Difficulty = {
      Easy: {
        size: 6,
        ratio: 90,
      },
      Normal: {
        size: 10,
        ratio: 80,
      },
      Hard: {
        size: 20,
        ratio: 70,
      },
    };

    class Cell {
      static initial = "O";
      static toggled = "·";
      static flag = "F";
      static size = 3;

      constructor(x, y, content) {
        this.x = Math.round(x);
        this.y = Math.round(y);
        this.width = Cell.size;
        this.height = Cell.size;
        this.content = content;
        this.revealed = false;
        this.neighbors = [];
      }

      onClick(board, kind) {
        if (kind === "right" && !this.revealed) {
          this.content = this.content === Cell.flag ? Cell.initial : Cell.flag;
        }
      }

      getBox() {
        return [
          ["╔", "-", "╗"],
          ["|", this.content, "|"],
          ["╚", "_", "╝"],
        ];
      }
    }

    class EmptyCell extends Cell {
      constructor(x, y) {
        super(x, y, Cell.initial);
      }

      onClick(board, kind) {
        if (kind === "right") super.onClick(board, kind);
        if (kind === "left") {
          this.reveal();
        }
      }

      reveal() {
        if (this.revealed) return;

        this.revealed = true;

        let count = 0;
        this.neighbors.forEach((n) => {
          count += n instanceof MineCell ? 1 : 0;
        });

        if (count > 0) this.content = count;
        else {
          this.content = Cell.toggled;
          this.neighbors.forEach((n) => {
            n?.reveal();
          });
        }
      }
    }

    class MineCell extends Cell {
      constructor(x, y) {
        super(x, y, Cell.initial);
      }

      onClick(board, kind) {
        if (kind === "right") super.onClick(board, kind);
        else {
          super.content = "M";
          board.gameOver();
        }
      }

      reveal() {}
    }

    class Renderer {
      constructor(boardElement) {
        this.boardElement = boardElement;
        this.width = 0;
      }

      next(width = 20, height = 20) {
        this.boardElement.textContent = "";
      }

      appendText(...text) {
        this.width = text[0].split("\r\n")[0]?.length ?? 0;
        this.boardElement.textContent += text.join("\r\n");
      }

      generateTitle(text, width = 10, delimiter = "·") {
        return (
          this.generateTextRow("", width, delimiter) +
          this.generateTextRow(text, width, delimiter) +
          this.generateTextRow("", width, delimiter)
        );
      }

      generateTextRow(text, width = 10, delimiter = "·") {
        const padding = [...new Array(width)].map((_) => delimiter).join("");
        const title =
          padding.substring(0, padding.length / 2 - text.length / 2 + 1) +
          text +
          padding.substring(0, padding.length / 2 - text.length / 2) +
          "\r\n";

        return title;
      }
    }

    class Scene {
      constructor(renderer, width, height, endScene) {
        this.width = width;
        this.height = height;
        this.renderer = renderer;
        this.renderer.next();
        this.endScene = endScene;
      }

      onClick(width, height) {}
    }

    class BoardScene extends Scene {
      constructor(renderer, difficulty, endScene) {
        super(renderer, 0, 0, endScene);
        this.elements = [];
        this.gameOverFlag = false;
        this.generateCells(difficulty);
        this.width = Math.max(
          ...this.elements.map(
            (element) =>
              element.x + Math.max(...element.getBox().map((r) => r.length)),
          ),
        );
        this.height = Math.max(
          ...this.elements.map(
            (element) => element.y + element.getBox().length,
          ),
        );
      }

      gameOver() {
        this.gameOverFlag = true;
        this.endScene({ game: "lost" });
      }

      generateCells(difficulty) {
        const size = difficulty.size;
        const ratio = difficulty.ratio;
        const elements = [...new Array(size * size)].map((_, index) => {
          const x = index % size;
          const y = Math.floor(index / size) % size;
          const value = Math.random() * 100;

          if (value > ratio) return new MineCell(x * Cell.size, y * Cell.size);
          else return new EmptyCell(x * Cell.size, y * Cell.size);
        });

        this.elements = elements;

        elements.forEach((element) => {
          const x = element.x + 1;
          const y = element.y + 1;

          const niggas = [];

          niggas.push(
            this.getElement(x - Cell.size, y - Cell.size),
            this.getElement(x, y - Cell.size),
            this.getElement(x + Cell.size, y - Cell.size),
            this.getElement(x + Cell.size, y),
            this.getElement(x + Cell.size, y + Cell.size),
            this.getElement(x, y + Cell.size),
            this.getElement(x - Cell.size, y + Cell.size),
            this.getElement(x - Cell.size, y),
          );

          element.neighbors = niggas;
        });
      }

      printBoard() {
        this.tiles = [...new Array(this.height)].map((_) => [
          ...[...new Array(this.width)].map((_) => ""),
        ]);

        this.elements.map((element) => {
          element
            .getBox()
            .map((row, boxY) =>
              row.map(
                (boxTile, boxX) =>
                  (this.tiles[element.y + boxY][element.x + boxX] = boxTile),
              ),
            );
        });

        return this.tiles;
      }

      getElement(x, y) {
        for (const element of this.elements) {
          const collisionY = y >= element.y && y <= element.y + element.height;
          const collisionX = x >= element.x && x <= element.x + element.width;
          if (collisionX && collisionY) return element;
        }
      }

      onClick({ type, x, y, kind }) {
        if (type === "keyboard") return;

        const element = this.getElement(x * this.width, y * this.height);
        element.onClick(this, kind);
        if (this.gameOverFlag) return;
        this.renderer.next();
        this.render();
      }

      render() {
        this.renderer.appendText(
          this.printBoard()
            .map((row) => row.join(""))
            .join("\r\n"),
        );
      }
    }

    class GameOverScene extends Scene {
      constructor(renderer, nextScene) {
        super(renderer, 45, 0, nextScene);
      }

      onClick({ type, keyCode }) {
        if (type === "keyboard") {
          if (keyCode === Keyboardkeys.Space) {
            this.endScene();
          }
          return;
        }
      }

      render(element) {
        this.renderer.appendText(
          this.renderer.generateTitle(Game.gameOverText, this.width),
        );
        this.renderer.appendText(
          this.renderer.generateTitle("Press 'Space' to RestartX", this.width),
        );
      }
    }

    class StartGameScene extends Scene {
      constructor(renderer, endScene) {
        super(renderer, 45, 80, endScene);
        this.arrow = {
          text: "=>",
          index: 1,
          count: 3,
        };
      }

      getArrow(position) {
        return (
          (Math.abs(this.arrow.index) % this.arrow.count === position
            ? " " + this.arrow.text
            : "   ") + " "
        );
      }

      onClick({ type, kind, keyCode }) {
        if (kind === "keyPress") {
          keyCode === Keyboardkeys.One
            ? this.endScene({ difficulty: Difficulty.Easy })
            : false;
          keyCode === Keyboardkeys.Two
            ? this.endScene({ difficulty: Difficulty.Normal })
            : false;
          keyCode === Keyboardkeys.Three
            ? this.endScene({ difficulty: Difficulty.Hard })
            : false;
          keyCode === Keyboardkeys.Up ? this.arrow.index-- : false;
          keyCode === Keyboardkeys.Down ? this.arrow.index++ : false;
          if (keyCode === Keyboardkeys.Enter) {
            this.endScene({
              difficulty:
                Object.values(Difficulty)[
                  Math.abs(this.arrow.index) % this.arrow.count
                ],
            });
            return;
          }
        }

        this.renderer.next();
        this.render();
      }

      render(element) {
        this.renderer.appendText(
          this.renderer.generateTextRow("", this.width, " "),
          this.renderer.generateTitle(
            "Welcome to MINE SWEEPERS ASCII (modern)",
            this.width,
          ),
          this.renderer.generateTitle(
            "Use Your Arrows to Select Difficulty",
            this.width,
            " ",
          ),
          this.renderer.generateTitle(
            this.getArrow(0) + "Press 1 - if you are a baby",
            this.width,
          ),
          this.renderer.generateTitle(
            this.getArrow(1) + "Press 2 - if your name is joe",
            this.width,
          ),
          this.renderer.generateTitle(
            this.getArrow(2) + "Press 3 - if your name is gay",
            this.width,
          ),
          this.renderer.generateTextRow(
            this.arrow.index === 2 ? "Feeling gangsta?" : "",
            this.width,
            " ",
          ),
          this.renderer.generateTitle(
            "*** And then Press Enter ***",
            this.width,
            " ",
          ),
        );
      }
    }

    class Game {
      static gameOverText = "! Game Over Bitch !";
      constructor() {
        const boardElement = document.getElementById("board");
        boardElement.onclick = (e) => this.onClick(e, this, "left");
        boardElement.addEventListener("contextmenu", (e) =>
          this.onClick(e, this, "right"),
        );
        document.body.onkeypress = (e) => {
          this.currentScene.onClick({
            type: "keyboard",
            kind: "keyPress",
            keyCode: e.keyCode,
          });
        };
        document.addEventListener("keydown", (e) => {
          this.currentScene.onClick({
            type: "keyboard",
            kind: "keyPress",
            keyCode: e.keyCode,
          });
        });
        this.renderer = new Renderer(boardElement);
        this.nextScene({ caller: "init" });
      }

      nextScene({ caller, args }) {
        if (caller === "startGame") {
          this.currentScene = new BoardScene(
            this.renderer,
            args.difficulty,
            (game) => this.nextScene({ caller: "board", game }),
          );
        }
        if (caller === "board") {
          this.currentScene = new GameOverScene(this.renderer, () =>
            this.nextScene({ caller: "gameOver" }),
          );
        }
        if (caller === "gameOver" || caller === "init") {
          this.currentScene = new StartGameScene(this.renderer, (difficulty) =>
            this.nextScene({ caller: "startGame", args: difficulty }),
          );
        }

        this.renderer.next();
        this.currentScene.render();
      }

      start() {
        this.currentScene.render();
      }

      onClick(e, game, kind) {
        e.preventDefault();

        const bounding = e.target.getBoundingClientRect();

        const relativeX =
          (e.clientX - bounding.x) /
          (bounding.width - bounding.x / this.currentScene.width);
        const relativeY =
          (e.clientY - bounding.y) /
          (bounding.height - bounding.x / this.currentScene.height);

        this.currentScene.onClick({
          type: "mouse",
          kind: kind,
          x: relativeX,
          y: relativeY,
        });
      }
    }

    class Page {}

    const game = new Game();
  </script>
  <style>
    body {
      color: rgb(68, 164, 68);
      background-color: rgb(15, 15, 15);
      overflow: scroll;
    }

    #board {
      font-family: "Courier New", Courier, monospace;
      white-space: pre-wrap;
      letter-spacing: 1ch;
      cursor: pointer;
      position: fixed;
    }
  </style>
</html>
